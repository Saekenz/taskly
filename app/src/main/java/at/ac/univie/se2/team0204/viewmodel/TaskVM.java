package at.ac.univie.se2.team0204.viewmodel;

import android.app.Application;
import android.os.Environment;
import android.util.Log;

import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import at.ac.univie.se2.team0204.model.TaskRepository;
import at.ac.univie.se2.team0204.model.room.Appointment;
import at.ac.univie.se2.team0204.model.room.AppointmentWithAttachments;
import at.ac.univie.se2.team0204.model.room.Attachment;
import at.ac.univie.se2.team0204.model.room.Task;
import at.ac.univie.se2.team0204.model.room.TaskDatabase;
import at.ac.univie.se2.team0204.model.room.Todo;
import at.ac.univie.se2.team0204.model.room.TodoWithAttachments;
import at.ac.univie.se2.team0204.model.room.TodoWithSubTodos;
import at.ac.univie.se2.team0204.view.MainActivity;
import at.ac.univie.se2.team0204.viewmodel.convert.IConverter;
import at.ac.univie.se2.team0204.viewmodel.convert.JSONConverter;
import at.ac.univie.se2.team0204.viewmodel.convert.XMLConverter;
import at.ac.univie.se2.team0204.viewmodel.taskfactory.AppointmentFactory;
import at.ac.univie.se2.team0204.viewmodel.taskfactory.TaskFactory;
import at.ac.univie.se2.team0204.viewmodel.taskfactory.TodoFactory;
import at.ac.univie.se2.team0204.viewmodel.verify.InputVerifier;

/**
 * The VM handles all the live data logic and passes storage persistence to the repository. An example
 * of how to do so is shown in the insertTodo function. In the constructor the database connection
 */
public class TaskVM extends AndroidViewModel {

    //Todo: Should we use the super class Task?

    /**
     * Contains all {@link Todo} objects in the database.
     */
    private LiveData<List<Todo>> todoLiveData;

    /**
     * Contains all {@link Appointment} objects in the database.
     */
    private LiveData<List<Appointment>> appointmentLiveData;

    /**
     * The {@link TaskRepository} is the gateway of the {@link TaskVM} to the database tables.
     */
    private final TaskRepository repository;

    /**
     * Tag used by the logger to identify this class
     */
    private static final String TAG = "TaskVM";

    /**
     * Creates a new {@link TaskVM} and initializes all its fields.
     * @param application
     */
    public TaskVM(Application application) {
        super(application);
        TaskDatabase database = TaskDatabase.getRoomDatabase(application);

        repository = new TaskRepository(database.toDoDao(), database.appointmentDao(), database.attachmentDao());
        appointmentLiveData = repository.getAppointments();
        todoLiveData = repository.getTodos();
    }

    /**
     * Checks the type of a {@link Task} and inserts it into the database.
     * @param task The {@link Task} that will be inserted.
     */
    public void insertTask(Task task) {
        if(task instanceof Appointment) {
            this.repository.insertAppointment((Appointment) task);
        }
        if(task instanceof Todo) {
            this.repository.insertTodo((Todo) task);
        }

    }

    /**
     * Inserts a new {@link Task} into the database and returns the autogenerated ID.
     * @param task The object that should be inserted into the database (can be {@link Appointment} or {@link Todo}).
     * @return The autogenerated ID of the inserted object or -1 if neither {@link Appointment}/{@link Todo}
     */
    public long insertTaskAndReturnID(Task task){
        if(task instanceof Appointment) {
            return this.repository.insertAppointmentAndReturnID((Appointment) task);
        }
        if(task instanceof Todo) {
            return this.repository.insertTodoAndReturnID((Todo) task);
        }
        return -1;
    }

    /**
     * Returns the all {@link Todo} objects in a LiveData container.
     * @return The {@link Todo} objects.
     */
    public LiveData<List<Todo>> getTodoLiveData() {
        return todoLiveData;
    }

    /**
     * Returns the all {@link Appointment} objects in a LiveData container.
     * @return The {@link Appointment} objects.
     */
    public LiveData<List<Appointment>> getAppointmentLiveData() {
        return appointmentLiveData;
    }

    public int getTodoByTitleAndDesc(String title, String desc) {
        int id = this.repository.getTodoByTitleAndDesc(title, desc);
        Log.d(TAG,"TaskID = "+id);
        return id;
    }

    public List<AppointmentWithAttachments> getAppointmentWithAttachments() {
        return this.repository.getAppointmentWithAttachments();
    }

    public List<TodoWithAttachments> getTodoWithAttachments() {
        return this.repository.getTodoWithAttachments();
    }

    /**
     * Fetches a {@link TodoWithSubTodos} object containing a {@link Todo} and its children.
     * @param id The taskID of the Parent {@link Todo} object.
     * @return The {@link TodoWithSubTodos} object matching the ID.
     */
    public TodoWithSubTodos getTodoWithSubTodosByID(int id) {
        return this.repository.getTodoWithSubTodosByID(id);
    }

    /**
     * Fetches a list with all {@link TodoWithSubTodos} objects from the database.
     * @return List containing every {@link Todo} and its children.
     */
    public List<TodoWithSubTodos> getTodosWithSubTodos() {
        return this.repository.getTodosWithSubTodos();
    }

    /**
     * Deletes the {@link Todo} object matching the id parameter and all its children from the database.
     * @param id The taskId of the to be deleted {@link Todo} object.
     */
    public void deleteTodoAndSubTodosById(int id) {
        this.repository.deleteTodoAndSubTodosById(id);
    }

    /**
     * Returns the right type of {@link IConverter}. This function should help implementing the Open-Close principle. If a new
     * file type should be added, a new IConverter can be defined and returned by this function.
     *
     * @param contentType The file ending of import.
     * @return Either an {@link XMLConverter} or a @{@link JSONConverter}.
     */
    private IConverter getIterator(String contentType) {
        if(contentType.contains("xml")) {
            return new XMLConverter();
        } else {
            return new JSONConverter();
        }
    }

    /**
     * This method acts as a facade for importing {@link Task}s. All required logic is called from this method.
     *<p>
     *     The method reads in files from an input stream and converts them to a string. From this string on all further
     *     processing of imported {@link Task}s is called, such as conversion, verification and database insertion.
     *</p>
     * @param inputStream This stream is generated using the Uri picked by the user in the {@link MainActivity}. It is used to load the file.
     */
    public void importTask(InputStream inputStream, String contentType) {

        int updatedOrInsertedTasks = 0;
        Log.i(TAG, "Importing started");

        String rawTasks = FileManager.readFile(inputStream);

        IConverter converter = getIterator(contentType);
        TaskImportIterator taskIterator;

        try {
            taskIterator = converter.convertToIterator(rawTasks);
        } catch (Exception e) {
            Log.e(TAG, e.getMessage());
            return;
        }

        Log.d(TAG, "Starting import iterations. Size of iterator: " + taskIterator.getIteratorSize());
        Map<String, String> nextTask;
        InputVerifier inputVerifier = new InputVerifier();
        TaskFactory factory;
        while(taskIterator.hasNext()) {
            nextTask = taskIterator.next();

            Log.d(TAG, "Importing task");

            // Verify Task Structure
            try {
                inputVerifier.verifyInput(nextTask);
            } catch (Exception e) {
                Log.e(TAG, e.getMessage());
                Log.e(TAG, "Task will be skipped");
                e.printStackTrace();
                continue;
            }

            // Check Task Type
            // We do not have to check for null values, as the type checker already does
            if(Objects.equals(nextTask.get("taskType"), "ToDo")) {

                Log.d(TAG, "Importing todo task");

                factory = new TodoFactory();
                Todo todo = (Todo) factory.createTask(nextTask);
                // If the taskId exists and a task with the same id exists, we synchronize an existing one
                if(nextTask.containsKey("taskId")) {

                    // Seems a bit ugly
                    Todo similarTodo = repository.getTodo(Objects.requireNonNull(nextTask.get("taskId")));
                    if (similarTodo != null) {
                        // Synchronize existing appointment
                        repository.updateTodo(todo);

                        Log.d(TAG, "Task already exists and was updated");
                        updatedOrInsertedTasks++;
                        continue;
                    }
                }

                repository.insertTodo(todo);

                Log.d(TAG, "Task did not exist yet and was added to DB");
                updatedOrInsertedTasks++;
            } else if (Objects.equals(nextTask.get("taskType"), "Appointment")) {

                Log.d(TAG, "Importing appointment task");

                factory = new AppointmentFactory();
                Appointment appointment = (Appointment) factory.createTask(nextTask);

                // If the taskId exists and a task with the same id exists, we synchronize an existing one
                if(nextTask.containsKey("taskId")) {

                    // Seems a bit ugly
                    Appointment similarAppointment = repository.getAppointment(Objects.requireNonNull(nextTask.get("taskId")));
                    if(similarAppointment != null) {
                        // Synchronize existing appointment
                        repository.updateAppointment(appointment);

                        Log.d(TAG, "Task already exists and was updated");
                        updatedOrInsertedTasks++;
                        continue;
                    }
                }

                repository.insertAppointment(appointment);
                Log.d(TAG, "Task did not exist yet and was added to DB");
                updatedOrInsertedTasks++;
            }
        }

        Log.i(TAG, "Finished inserting tasks. " + updatedOrInsertedTasks + " tasks were updated or inserted.");
    }

    /**
     * This method calls all required functions to export a {@link Task} into a file.
     *
     * @param taskId The {@link Task} that should be exported.
     * @param contentType The file ending of the newly created file.
     */
    public void export(int taskId, String contentType, String taskType) {

        Task task;
        if(taskType.equals("Appointment")) {
            task = repository.getAppointment(Integer.toString(taskId));
        } else {
            task = repository.getTodo(Integer.toString(taskId));
        }

        Log.i(TAG, "Started exporting");

        // Convert task
        IConverter converter;
        String convertedTask;
        if(contentType.equals("json")) {
            converter = new JSONConverter();
        } else {
            converter = new XMLConverter();
        }
        convertedTask = converter.convertToString(task);

        Log.i(TAG, "Finished converting");

        FileManager.writeFile(contentType, convertedTask);
    }

    /**
     * Selects a specific {@link Appointment} from the database using its id.
     * @param taskId The id of the selected {@link Appointment}.
     * @return The selected {@link Appointment}.
     */
    public Appointment getAppointment(int taskId) {
        return this.repository.getAppointment(String.valueOf(taskId));
    }

    /**
     * Selects a specific {@link Todo} from the database using its id.
     * @param taskId The id of the selected {@link Todo}.
     * @return The selected {@link Todo}.
     */
    public Todo getTodo(int taskId) {
        return this.repository.getTodo(String.valueOf(taskId));
    }
}
